# 算法&数据结构

## 专题一: 动态规划

### (一)

#### 题目1

```
假设有排成一行的N个位置记为1~N，N一定大于或等于2
开始时机器人在其中的start位置上(start一定是1~N中的一个)
如果机器人来到1位置，那么下一步只能往右来到2位置；
如果机器人来到N位置，那么下一步只能往左来到N-1位置；
如果机器人来到中间位置，那么下一步可以往左走或者往右走；
规定机器人必须走K步，最终能来到dest位置(dest也是1~N中的一个)的方法有多少种
给定四个参数 N、start、K、dest，返回方法数
```

思考:此题无论用什么方法,描述机器人在每个位置时的**状态**是关键-------样本对应模型

状态: 当前位置cur,   剩余步数 rest

暴力递归法:

base case :

1). 方法停止调用,返回统计结果----> rest =0

 来到rest =0 时,方法结束调用的条件 ,不代表此递归路线的结果是满足题意的一种有效方法

根据题意最终机器人来到dest位置才算一种符号要求的方法,则要判断cur==des?1:0;

2).cur==1, 机器人只能向右走

3).cur==N,机器人只能向左走



```
    public static int ways1(int N, int start, int dest, int K) {
        if (N < 2 || start < 1 || start > N || dest < 1 || dest > N || K < 1) {
            return -1;
        }

        return f(N, dest, start, K);
    }

    public static int f(int N, int dest, int cur, int rest) {
        if (rest == 0) {
            return cur == dest ? 1 : 0;
        }

        if (cur == 1) {
            return f(N, dest, 2, rest - 1);
        }
        if (cur == N) {
            return f(N, dest, N - 1, rest - 1);
        }

        return f(N, dest, cur - 1, rest - 1) + f(N, dest, cur + 1, rest - 1);

    }
```



缓存法: 基于暴力递归,只是将递归过程的每一步的结果,存入缓存,以避免不必要的二次计算,提高速度

```
public static int ways2(int N, int start, int dest, int K) {
    if (N < 2 || start < 1 || start > N || dest < 1 || dest > N || K < 1) {
        return -1;
    }

    int[][] dp = new int[N + 1][K + 1];
    for (int i = 0; i <= N; i++) {
        for (int j = 0; j <= K; j++) {
            dp[i][j] = -1;
        }
    }
    return f2(N, dest, start, K, dp);
}

public static int f2(int N, int dest, int cur, int rest, int[][] dp) {
    if (dp[cur][rest] != -1) {
        return dp[cur][rest];
    }

    int ans = 0;

    if (rest == 0) {
        ans = cur == dest ? 1 : 0;
    } else if (cur == 1) {
        ans = f2(N, dest, 2, rest - 1, dp);
    } else if (cur == N) {
        ans = f2(N, dest, N - 1, rest - 1, dp);
    } else {
        ans = f2(N, dest, cur - 1, rest - 1, dp) + f2(N, dest, cur + 1, rest - 1, dp);
    }

    dp[cur][rest] = ans;

    return ans;
}
```



动态规划:基于前两种方法,找出变化因素,以及依赖关系



```
public static int ways3(int N, int start, int dest, int K) {
    if (N < 2 || start < 1 || start > N || dest < 1 || dest > N || K < 1) {
        return -1;
    }

    int[][] dp = new int[N + 1][K + 1];
    dp[dest][0] = 1;
    for (int rest = 1; rest <= K; rest++) {
        dp[1][rest] = dp[2][rest - 1];
        for (int cur = 2; cur < N; cur++) {
            dp[cur][rest] = dp[cur - 1][rest - 1] + dp[cur + 1][rest - 1];
        }
        dp[N][rest] = dp[N - 1][rest - 1];
    }

    return dp[start][K];
}
```













#### 题目2

```
给定一个整型数组arr，代表数值不同的纸牌排成一条线
玩家A和玩家B依次拿走每张纸牌
规定玩家A先拿，玩家B后拿
但是每个玩家每次只能拿走最左或最右的纸牌
玩家A和玩家B都绝顶聪明
请返回最后获胜者的分数
```

思考: ----范围模型

1.与上题描述机器人状态不同的是,此题随着玩家依次拿走每张纸牌,数组的可用范围在不断缩小,------需要用到L, R 变量 表示数组的有效范围, 所以此题需要用到范围上的动态规划

2.绝顶聪明意味着什么----------不会只思考当前步骤的利益,而是整个结果利益最大化

3.先手后手在过程中身份会不断交替

4.如何描述先手的玩牌过程,以及后手的玩牌过程----------身份的不同意味着玩牌过程的利益最大化的不同



暴力递归:

根据思考的过程, 需要有两个递归方程描述先手后手的玩牌,

定义先手递归:f(int[] arr, int L, int R), 后手递归:g(int[] arr, int L, int R)

base case :

结束条件 L==R,

f():  return   arr[L]

g(): return    0

在整个活动只剩下一张牌时,随着先手将其拿走,后手只能被动结束

f():整个利益最大化:  Math.max(arr[L]+g(arr,L+1,R),arr[R]+g(arr,L+R-1));

g():被动者最大化利益===使对方的利益最小化:  Math.min(f(arr,L+1,R),f(arr,L,R-1));

注意: 在每个角色过程中所调用另一角色的函数一定视之为对方,不然会掉入深渊无底洞

```
public static int way1(int[] arr){
    if(arr==null||arr.length<1){
        return 0;
    }
    int N = arr.length;
    return Math.max(f(arr,0,N-1), g(arr,0,N-1));
}


public static int f(int[] arr, int L, int R){
    if(L==R){
        return arr[L];
    }
    int p1 = arr[L]+g(arr,L+1, R);
    int p2 = arr[R]+g(arr,L,R-1);
    return Math.max(p1,p2);
}


public static int g(int[] arr, int L, int R){
    if(L==R){
        return 0;
    }
    int p1 =f(arr,L+1, R);
    int p2= f(arr,L,R-1);
    return Math.min(p1,p2);
}
```



缓存法:这两个不同的函数需要两个缓存

```
public static int way2(int[] arr) {
    if (arr == null || arr.length < 1) {
        return 0;
    }
    int N = arr.length;
    int[][] fmap = new int[N][N];
    int[][] gmap = new int[N][N];

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            fmap[i][j] = -1;
            gmap[i][j] = -1;
        }
    }


    return Math.max(f1(arr, 0, N - 1, fmap, gmap), g1(arr, 0, N - 1, fmap, gmap));

}

public static int f1(int[] arr, int L, int R, int[][] fmap, int[][] gmap) {
    if (fmap[L][R] != -1) {
        return fmap[L][R];
    }
    int ans = 0;
    if (L == R) {
        ans = arr[L];
    } else {
        ans = Math.max(arr[L] + g1(arr, L + 1, R, fmap, gmap), arr[R] + g1(arr, L, R - 1, fmap, gmap));

    }
    fmap[L][R] = ans;

    return ans;

}

public static int g1(int[] arr, int L, int R, int[][] fmap, int[][] gmap) {
    if (gmap[L][R] != -1) {
        return gmap[L][R];
    }
    int ans = 0;
    if (L != R) {
        int p1 = f1(arr, L + 1, R, fmap, gmap);
        int p2 = f1(arr, L, R - 1, fmap, gmap);
        ans = Math.min(p1, p2);
    }

    gmap[L][R] = ans;

    return ans;
}
```



动态规划:基于前两种方法

```
public static int way3(int[] arr) {
    if (arr == null || arr.length < 1) {
        return 0;
    }
    int N = arr.length;
    
    int[][] fmap = new int[N][N];
    
    int[][] gmap = new int[N][N];
    
    for (int i = 0; i < N; i++) {
        fmap[i][i] = arr[i];
    }
    
    for (int i = 1; i < N; i++) {
        int L =0;
        int R = i;
        while(R<N){
            fmap[L][R] = Math.max(arr[L]+gmap[L+1][R],arr[R]+gmap[L][R-1]);
            gmap[L][R] = Math.min(fmap[L+1][R],fmap[L][R-1]);
            L++;
            R++;
        }

    }
```

注: while 中的L++, R++ 的意义





### (二)

#### 题目1

```
背包问题
给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表 i号物品的重量和价值
给定一个正数bag，表示一个载重bag的袋子，装的物品不能超过这个重量
返回能装下的最大价值
```



思考: 经典的从左往右尝试的模型-------描述当前位置cur的状态以及剩余rest



暴力递归的尝试:

base case:

rest < 0  返回无效值

cur == N 返回0

```
public static int way1(int[] weights, int[] values,int bag){
    if (weights==null||values==null||weights.length!=values.length||bag<0){
        return -1;
    }
    return  f(weights,values,weights.length,0,bag);
}

public static int f(int[] weights, int[] values,int N,int cur, int rest){
    if(rest<0){
        return -1;
    }

    if (cur==N){
        return 0;
    }
    int p1 = f(weights,values,N,cur+1,rest);
    int p2 = 0;
    int next = f(weights,values,N,cur+1,rest-weights[cur]);//因为rest -weights[cur]有可能小于0 所以要判断一下是否是有效值
    if(next!=-1){
        p2 = values[cur]+next;
    }
    return Math.max(p1,p2);
}
```



动态规划:(有了暴力递归的尝试,缓存法可以忽略直接写出动态规划)

```
public static int way2(int[] w, int[] v, int bag){
    if (w==null||v==null||w.length!=v.length||bag<0){
        return -1;
    }
    int N = w.length;
    int[][] dp = new int[N+1][bag+1];

    for (int cur = N-1; cur >=0 ; cur--) {
        for (int rest = 0; rest <=bag; rest++) {
            int p1 = dp[cur+1][rest];
            int p2 =0;
            int next = rest-w[cur]<0?-1:dp[cur+1][rest-w[cur]];
            if(next!=-1){
                p2 = v[cur]+next;
            }
            dp[cur][rest] = Math.max(p1,p2);
        }
    }

    return dp[0][bag];
}
```



#### 题目2

```
规定1和A对应、2和B对应、3和C对应...26和Z对应
那么一个数字字符串比如"111”就可以转化为:
"AAA"、"KA"和"AK"
给定一个只有数字字符组成的字符串str，返回有多少种转化结果 
```

思考: 从左往右的模型

暴力尝试:

base case :

当cur index 来到字符串第N个位置时,说明之前的方案是有效的一种,返回1

如果中途cur位置的数字是0或者和cur+1位置组成的数字大于26则是无效的,返回无效解 0

```
public static int way1(String str) {
    if (str == null || str.length() == 0) {
        return 0;
    }
    char[] strs = str.toCharArray();
    return f(strs, 0);
}


public static int f(char[] strs, int cur) {
    if (cur == strs.length) {
        return 1;
    }

    if (strs[cur]=='0') {
        return 0;
    }

    int p1 = f(strs, cur+1);
    int p2 = cur+1<strs.length&&(strs[cur] - '0') * 10 + (strs[cur+1] - '0') < 27 ? f(strs, cur+2) : 0;
    return p1+p2;


}
```



动态规划: 暴力尝试来看, 只有一个变量cur, 则创建一个一维数组dp



```
public static int way2(String s){
    if (s==null||s.length()<1){
        return 0;
    }

    char[] str = s.toCharArray();
    int N = str.length;
    int[] dp = new int[N+1];
    dp[N] = 1;
    for (int i = N-1; i >=0 ; i--) {
        if(str[i]!='0'){
            dp[i] = dp[i+1];
            dp[i] += i+1<N&&(str[i]-'0')*10+str[i+1]-'0'<27?dp[i+2]:0;
        }

    }

    return dp[0];
}
```





#### 题目3

```
给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文
arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来
返回需要至少多少张贴纸可以完成这个任务
例子：str= "babac"，arr = {"ba","c","abcd"}
ba + ba + c  3  abcd + abcd 2  abcd+ba 2
所以返回2
```



思考: 样本对应模型

1.用贴纸完成剪拼出str 与str的字符顺序无关,只需包含str所有字符的最少贴纸, 

2.字符串相减的过程可以暂时想象成黑盒,集中精力处理递归流程

暴力:

basecase : target.length==0



```
public static int fun1(String str, String[] strings) {
    int ans = process1(str, strings);
    return ans == Integer.MAX_VALUE ? -1 : ans;
}


public static int process1(String target, String[] stickers) {
    if (target.length() == 0) {
        return 0;
    }

    int next = Integer.MAX_VALUE;
    for (int i = 0; i < stickers.length; i++) {
        String rest = getRest(target, stickers[i]);

        next = Math.min(process1(rest, stickers), next);

    }

    return next + (next == Integer.MAX_VALUE ? 0 : 1);
}

public static String getRest(String a, String b) {
    char[] aStr = a.toCharArray();
    char[] bStr = b.toCharArray();
    int[] count = new int[26];
    for (char item : aStr) {
        count[item - 'a']++;
    }
    for (char item : bStr) {
        count[item - 'a']--;
    }
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < 26; i++) {
        if (count[i] > 0) {
            for (int j = 0; j < count[i]; j++) {
                builder.append('a' + i);
            }
        }
    }

    return builder.toString();
}
```



暴力:剪枝优化版

```
public static int fun2(String str, String[] strings) {
    int n = strings.length;
    int[][] counts = new int[n][26];
    for (int i = 0; i < n; i++) {
        for (char item : strings[i].toCharArray()) {
            counts[i][item - 'a']++;
        }
    }
    int ans = process2(str, counts);

    return ans == Integer.MAX_VALUE ? -1 : ans;

}


public static int process2(String target, int[][] counts) {
    if (target.length() == 0) {
        return 0;
    }

    int[] count = new int[26];
    char[] tar = target.toCharArray();
    for (char cha : tar) {
        count[cha - 'a']++;
    }

    int next = Integer.MAX_VALUE;
    for (int i = 0; i < counts.length; i++) {
        if (counts[i][tar[0] - 'a'] > 0) {
            StringBuilder builder = new StringBuilder();
            for (int j = 0; j < 26; j++) {
                int nums = count[j] - counts[i][j];
                if (nums > 0) {
                    for (int k = 0; k < nums; k++) {
                        builder.append(j + 'a');
                    }
                }
            }
            String rest = builder.toString();
            next = Math.min(process2(rest, counts), next);
        }

    }
    return next + (next == Integer.MAX_VALUE ? 0 : 1);
}
```



缓存:基于暴力优化版



```
public static int process3(String target, int[][] counts, HashMap<String, Integer> map) {
    if (target.length() == 0) {
        return 0;
    }
    if (map.containsKey(target)) {
        return map.get(target);
    }

    int[] count = new int[26];
    char[] tar = target.toCharArray();
    for (char cha : tar) {
        count[cha - 'a']++;
    }
    int next = Integer.MAX_VALUE;
    for (int i = 0; i < counts.length; i++) {
        if (counts[i][tar[0] - 'a'] > 0) {
            StringBuilder builder = new StringBuilder();
            for (int j = 0; j < 26; j++) {
                int nums = count[j] - counts[i][j];
                if (nums > 0) {
                    for (int k = 0; k < nums; k++) {
                        builder.append(j + 'a');
                    }
                }
            }
            String rest = builder.toString();
            next = Math.min(next, process3(rest, counts, map));
        }
    }
    int ans = next + (next == Integer.MAX_VALUE ? 0 : 1);
    map.put(target, ans);

    return ans;
}
```



#### 题目4*

```
给定两个字符串str1和str2，
返回这两个字符串的最长公共子序列长度
比如 ： str1 = “a12b3c456d”,str2 = “1ef23ghi4j56k”
最长公共子序列是“123456”，所以返回长度6
```









### (三)

#### 题目1

```
给定一个字符串str，返回这个字符串的最长回文子序列长度
比如 ： str = “a12b3c43def2ghi1kpm”
最长回文子序列是“1234321”或者“123c321”，返回长度7
```

思路:方法一:可以利用最长公共子序列解法,将字符串本身和其逆序字符串求得最长公共子序列的长度



方法二: 暴力递归模型之-------范围模型 f(arr,L, R) L, R 为数组的起始位置和结束位置表示arr从 L 到R 的范围上 求得的解

```
public static int way1(String s){
    char[] str = s.toCharArray();
    int N = str.length;
    return f1(str,0,N-1);
}
public static int f1(char[] str, int L, int R){

    if(L==R){
        return 1;
    }
    if(L+1==R){
        return str[L]==str[R]?2:1;
    }
    int p1 = f1(str,L+1,R);
    int p2 = f1(str,L,R-1);
    int p3 = f1(str,L+1,R-1);
    int p4 = str[L]==str[R]?p3+2:0;

    return Math.max(Math.max(p1,p2),Math.max(p3,p4));

}
```

方法三: 动态规划基于方法二

```

public static int f2(String s){
	char[] str = s.toCharArray();
    int N = str.length;
    int[][] dp = new int[N][N];
    for (int i = 0; i < N; i++) {
        dp[i][i] = 1;
        if(i+1<N){
            dp[i][i+1] = str[i]==str[i+1]?2:1;
        }
    }

    for (int L = N-3; L>=0; L--) {
        for (int R = L+2; R<N; R++) {
            int p1 = dp[L+1][R-1];
            int p2 = dp[L][R-1];
            int p3 = dp[L+1][R];
            int p4 = str[L]==str[R]?dp[L+1][R-1]+2:0;
            dp[L][R] = Math.max(Math.max(p1,p2), Math.max(p3,p4));
        }
    }
    return dp[0][N-1];
}
```









#### 题目2

```
请同学们自行搜索或者想象一个象棋的棋盘，
然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置
那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域
给你三个 参数 x，y，k
返回“马”从(0,0)位置出发，必须走k步
最后落在(x,y)上的方法数有多少种? 
```

 思路: 1. 需要了解象棋规则:马走日,象走田------业务限制模型

2. 如何表达马走日的位置变化--------(x+-2,y+-1) or( x+-1,y+-2)  ------八种方向可能

暴力递归:

```
public static int way1(int a, int b, int K) {

    return process1(0, 0, a, b, K);
}

public static int process1(int x, int y, int a, int b, int rest) {
    if (x < 0 || x > 9 || y < 0 || y > 8) {
        return 0;
    }
    if (rest == 0) {
        return (x == a && y == b) ? 1 : 0;
    }

    int ways = process1(x + 1, y + 2, a, b, rest - 1);
    ways += process1(x + 2, y + 1, a, b, rest - 1);
    ways += process1(x + 2, y - 1, a, b, rest - 1);
    ways += process1(x + 1, y - 2, a, b, rest - 1);
    ways += process1(x - 1, y - 2, a, b, rest - 1);
    ways += process1(x - 2, y - 1, a, b, rest - 1);
    ways += process1(x - 2, y + 1, a, b, rest - 1);
    ways += process1(x - 1, y + 2, a, b, rest - 1);
    return ways;
}
```



动态规划:

```
public static int way2(int a, int b, int K) {
    int[][][] dp = new int[10][9][K + 1];
    dp[a][b][0] = 1;
    for (int r = 1; r <= K; r++) {
        for (int x = 0; x < 10; x++) {
            for (int y = 0; y < 9; y++) {
                dp[x][y][r] = pick(dp, x + 1, y + 2, r - 1)
                        + pick(dp, x + 2, y + 1, r - 1)
                        + pick(dp, x + 2, y - 1, r - 1)
                        + pick(dp, x + 1, y - 2, r - 1)
                        + pick(dp, x - 1, y - 2, r - 1)
                        + pick(dp, x - 2, y - 1, r - 1)
                        + pick(dp, x - 2, y + 1, r - 1)
                        + pick(dp, x - 1, y + 2, r - 1);
            }

        }
    }
    return dp[0][0][K];
}


public static int pick(int[][][] dp, int x, int y, int rest) {
    if (x < 0 || x > 9 || y < 0 || y > 8) {
        return 0;
    }
    return dp[x][y][rest];
}
```



#### 题目3

```
给定一个数组arr，arr[i]代表第i号咖啡机泡一杯咖啡的时间
给定一个正数N，表示N个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡
只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯
每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发
假设所有人拿到咖啡之后立刻喝干净，
返回从开始等到所有咖啡机变干净的最短时间
三个参数：int[] arr、int N，int a、int b
```

思路: 业务限制模型

1.拆分过程-------喝完咖啡的过程  + 洗咖啡杯的过程-----------难点如何识别出需要拆分过程

2.喝完咖啡的过程 用小根堆模拟从排队到所有人喝完最快的结束时间, 注意 arr[i] 表示的是泡咖啡的时间间隔, 得到咖啡的时刻, 和喝完咖啡的时刻  这三者和最快时间的关系?

3.真正需要动态规划的是洗咖啡杯的过程

4.洗咖啡杯过程 要区分什么动作是串行,什么动作是并行

对于咖啡机而言 是串行

挥发是并行

但是每个咖啡杯变得干净结束的时间与剩下的咖啡杯变干净之间又是并行,虽然可能影响了washer的工作时间

暴力递归:

```
 public static int way(int[] arr, int N, int a, int b){
        if(arr==null||arr.length<1){
            return 0;
        }
        int[] coffes = getCoffee(arr,N);
       return process1(coffes,0,N, a, b,0);
    }
    public static int process1(int[] coffes, int cur,int N, int a, int b,int free){
        if(cur == N){
            return 0;
        }
        int washClean = Math.max(coffes[cur],free)+a;
        int restWash = process1(coffes,cur+1,N,a,b,washClean);
        int p1 = Math.max(washClean,restWash);

        int selfClean = coffes[cur]+b;
        int restSelf = process1(coffes,cur+1,N,a,b,free);
        int p2 = Math.max(selfClean,restSelf);
        return Math.min(p1,p2);

    }



public static int[] getCoffee(int[] arr, int N){
    int[] results = new int[N];
    PriorityQueue<CoffeTime> heap = new PriorityQueue<>(new MyComparator());
    for (int i = 0; i < arr.length; i++) {
       heap.add(new CoffeTime(0,arr[i]));
    }
    int i= 0;
    CoffeTime cur = null;
    while (i<N){
        cur = heap.poll();
        int time = cur.start+cur.minutes;
        results[i++] = time;
        heap.add(new CoffeTime(time,cur.minutes));
    }

    return results;
}

public static class CoffeTime{
    int start;
    int minutes;
    public CoffeTime (int s, int m){
        start = s;
        minutes = m;
    }

}


public static class MyComparator implements Comparator<CoffeTime>{

    @Override
    public int compare(CoffeTime o1, CoffeTime o2) {
        return (o1.start+o1.minutes) - (o2.start+o2.minutes);
    }
}
```



动态规划:

```

    public static int way2(int[] arr, int N, int a, int b){
        if(arr==null||arr.length<1){
            return 0;
        }
        int[] drinks = getCoffee(arr,N);
        int maxFree = 0;
        for (int i = 0; i < N; i++) {
            maxFree = Math.max(maxFree,drinks[i])+a;
        }

        int[][] dp = new int[N+1][maxFree+1];

        for (int i = N-1; i>=0; i--) {
            for (int free = 0; free <= maxFree; free++) {
                int washClean = Math.max(drinks[i],free)+a;
                int restWash = dp[i+1][washClean];
                int p1 = Math.max(washClean,restWash);

                int selfClean = drinks[i]+b;
                int restSelf = dp[i+1][free];
                int p2 = Math.max(selfClean,restSelf);
                dp[i][free] = Math.min(p1,p2);
            }
        }
        return dp[0][0];
    }


public static int[] getCoffee(int[] arr, int N){
    int[] results = new int[N];
    PriorityQueue<CoffeTime> heap = new PriorityQueue<>(new MyComparator());
    for (int i = 0; i < arr.length; i++) {
       heap.add(new CoffeTime(0,arr[i]));
    }
    int i= 0;
    CoffeTime cur = null;
    while (i<N){
        cur = heap.poll();
        int time = cur.start+cur.minutes;
        results[i++] = time;
        heap.add(new CoffeTime(time,cur.minutes));
    }

    return results;
}

public static class CoffeTime{
    int start;
    int minutes;
    public CoffeTime (int s, int m){
        start = s;
        minutes = m;
    }

}


public static class MyComparator implements Comparator<CoffeTime>{

    @Override
    public int compare(CoffeTime o1, CoffeTime o2) {
        return (o1.start+o1.minutes) - (o2.start+o2.minutes);
    }
}
```







### (四)

1.动态规划中的空间压缩 之 二维表结构依赖转一维:  此方法适用于依赖位置有限个

2.动态规划中每个位置依赖如果没有枚举行为,即for循环,则记忆化搜索和严格表结构效果等效.

3.位置中如果有枚举,则要观察位置的依赖有何规律,从而进行压缩

#### 题目1

```
给定一个二维数组matrix，一个人必须从左上角出发，最后到达右下角
沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和
返回最小距离累加和
```

暴力递归:

```
public static int way1(int[][] m) {
    if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
        return 0;
    }
    return process1(m, 0, 0);
}

public static int process1(int[][] m, int row, int col) {
    if (row == m.length || col == m[0].length) {
        return 0;
    }
    //最后一行只能向右走
    if (row == m.length - 1) {
        return process1(m, row, col + 1) + m[row][col];
    }
	//第一行最后一列只能向下走
    if (col == m[0].length - 1) {
        return process1(m, row + 1, col) + m[row][col];
    }

    return Math.min(process1(m, row, col + 1), process1(m, row + 1, col)) + m[row][col];
}
```

动态规划:

```
public static int way2(int[][] m) {
    if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
        return 0;
    }
    int row = m.length;
    int col = m[0].length;

    int[][] dp = new int[row][col];
    dp[0][0] = m[0][0];
    for (int i = 1; i < col; i++) {
        dp[0][i] = m[0][i] + dp[0][i - 1];
    }
    for (int i = 1; i < row; i++) {
        dp[i][0] = m[i][0] + dp[i - 1][0];
    }


    for (int i = 1; i < row; i++) {
        for (int j = 1; j < col; j++) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + m[i][j];
        }
    }
    return dp[row - 1][col - 1];
}
```

优化后的动态规划: 因为每个dp 的值依赖 dp表中左侧 和 上侧 的值 所以可以用一维arr 来进行更新, 更新后的arr[i-1] = 左侧的值   , 未更新的arr[i] = 上侧的值  , (如果依赖左上方  则 更新前的arr[i-1] 为左上方的值)

![image](https://user-images.githubusercontent.com/71537130/154783051-abe9b2f6-b6c1-4bac-bcbc-ae3693ea5e49.png)


```
public static int way3(int[][] m) {
    if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
        return 0;
    }
    int row = m.length;
    int col = m[0].length;

    int[] arr = new int[col];
    //第一行arr的值更新
    arr[0] = m[0][0];
    for (int i = 1; i < col; i++) {
        arr[i] = arr[i-1]+m[0][i];
    }
    //从第二行开始的更新
    for (int i = 1; i < row; i++) {
        arr[0] += m[i][0];
        for (int j = 1; j < col; j++) {
            arr[j] = Math.min(arr[j - 1], arr[j]) + m[i][j];
        }
    }

    return arr[col - 1];
}
```





#### 题目2

```
arr是货币数组，其中的值都是正数。再给定一个正数aim。
每个值都认为是一张货币，
即便是值相同的货币也认为每一张都是不同的，
返回组成aim的方法数
例如：arr = {1,1,1}，aim = 2
第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2
一共就3种方法，所以返回3
```

暴力递归:

```
public static int way1(int[] arr,int aim){
    if(arr==null||arr.length==0){
        return 0;
    }

    return process(arr,0,aim);
}

public static int process(int[] arr, int index, int rest){
    if(rest<0){
        return 0;
    }
    if(index==arr.length){
        return rest==0?1:0;
    }

    return process(arr,index+1,rest)+process(arr,index+1, rest-arr[index]);

}
```

动态规划:

```
public static int way2(int[]arr, int aim){
    if(arr==null||arr.length==0){
        return 0;
    }

    int N = arr.length;
    int[][] dp = new int[N+1][aim+1];
    dp[N][0] = 1;

    for (int i = N-1; i >=0 ; i--) {
        for (int j = 0; j <=aim; j++) {
            dp[i][j] = dp[i+1][j]+(j-arr[i]>=0? dp[i+1][j-arr[i]]:0);
        }
    }

    return dp[0][aim];
}
```

优化后的:因为每一行的dp值依赖下一行的dp值,所以可以优化

```
public static int way3(int[]arr, int aim){
    if(arr==null||arr.length==0){
        return 0;
    }
    int N = arr.length;
    int[] dp = new int[aim+1];
    dp[0] = 1;
    for (int i = N-1; i >=0 ; i--) {
        for (int j = 0; j <=aim; j++) {
            dp[j] = dp[j]+(j-arr[i]>=0?dp[j-arr[i]]:0);
        }

    }
   return dp[aim];
}
```





#### 题目3

```
arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。
每个值都认为是一种面值，且认为张数是无限的。
返回组成aim的方法数
例如：arr = {1,2}，aim = 4
方法如下：1+1+1+1、1+1+2、2+2
一共就3种方法，所以返回3
```

思路: 看似张数无限,实则隐藏着 i  * arr[index]<=rest 条件的制约



暴力递归:

```
public static int way1(int[] arr, int aim){
    if(arr==null||arr.length<1||aim<0){
        return 0;
    }
    return process(arr,0,aim);
}

public static int process(int[] arr,int index,int rest){
    if(index==arr.length){
        return rest==0?1:0;
    }
    int ways = 0;
    for (int i = 0; i * arr[index]<=rest ; i++) {
        ways+=process(arr,index+1,rest-(i*arr[index]));
    }

    return ways;
}
```

动态规划:

```
public static int way2(int[] arr,int aim){
    if(arr==null||arr.length<1||aim<0){
        return 0;
    }
    int N = arr.length;
    int[][] dp = new int[N+1][aim+1];
    dp[N][0] = 1;


    for (int i = N-1; i >=0; i--) {
        for (int rest = 0; rest <=aim; rest++) {
            int ways = 0;
            for (int item = 0; item * arr[i] <=rest ; item++) {
                ways+=dp[i+1][rest-(item*arr[i])];
            }
            dp[i][rest] = ways;
        }




    }
    return dp[0][aim];
}
```



优化后的: 因为每个dp 值 的产生 有枚举行为-----for循环  所以需要观察dp表中位置依赖的规律,进而进行优化



![image](https://user-images.githubusercontent.com/71537130/154783082-f1417fae-f26e-4da1-9fc4-0af75ae38675.png)




观察可知: 每个dp值即 ? 等于下一行的 a+b+c+d+e+.........     但是观察发现   * 号处的值(即使用了一张arr[i] 的情况)= b+c+d+e+.........    由此可知  ? = * +a  

```
public static int way3(int[] arr, int aim){
    if(arr==null||arr.length<1||aim<0){
        return 0;
    }
    int N = arr.length;
    int[][] dp = new int[N+1][aim+1];
    dp[N][0] = 1;
    for (int i = N-1; i >=0; i--) {
        for (int rest = 0; rest <=aim ; rest++) {
            dp[i][rest] = dp[i+1][rest]+(rest-arr[i]>=0?dp[i][rest-arr[i]]:0);
        }
    }

    return dp[0][aim];
}
```





#### 题目4

```
arr是货币数组，其中的值都是正数。再给定一个正数aim。
每个值都认为是一张货币，
认为值相同的货币没有任何不同，
返回组成aim的方法数
例如：arr = {1,2,1,1,2,1,2}，aim = 4
方法：1+1+1+1、1+1+2、2+2
一共就3种方法，所以返回3
```

思路:  很明显此题与上题的不同-----有了张数的限制

所以在可以先处理arr , 得到 coins[]  面值有哪些,  counts[]  面值对应的张数是多少

```
   
 	public static class Info{
        int[] coins;
        int[] counts;
        public Info(int[] c, int[] s){
            coins = c;
            counts = s;
        }
    }
   
   public static Info getInfo(int[] arr){

        HashMap<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < arr.length; i++) {
            if(!map.containsKey(arr[i])){
                map.put(arr[i],1);
            }else {
                map.put(arr[i],map.get(arr[i])+1);
            }
        }
        int N = map.size();
        int[] coins = new int[N];
        int[] counts = new int[N];
        int i =0;
        for(Entry<Integer,Integer> entry: map.entrySet()){
            coins[i]=entry.getKey();
            counts[i++] = entry.getValue();
        }

        return new Info(coins,counts);
    }
```

暴力递归:

```
public static int way1(int[] arr, int aim) {
    if (arr == null || arr.length < 0 || aim < 0) {
        return 0;
    }

    Info info = getInfo(arr);

    return process(info.coins,info.counts,0,aim);
}

public static int process(int[] coins, int[] counts, int index, int rest) {
    if (index == coins.length) {
        return rest == 0 ? 1 : 0;
    }
    int ways = 0;
    //多了张数最大值的限制
    for (int i = 0; i * coins[index] <= rest && i <= counts[index]; i++) {
        ways += process(coins, counts, index + 1, rest - (i * coins[index]));
    }

    return ways;
}
```



动态规划: 根据暴力递归, 与上题类型 此dp 依然是个三维的表,且dp值的产生有枚举行为,可以直接考虑观察dp值依赖规律,进行优化

![image](https://user-images.githubusercontent.com/71537130/154783105-1144f172-620c-4d3f-b818-6b2e9d894210.png)




 因为多了条件的限制, ? 取值的截至处是f ,  而 *   的取值截至处是g  即 :

 ? = a+b+c+d+e+f   ,  * =  b+c+d+e+f+g   观察可知 ? 和* 号 公共部分是 b~f ,所以 ? = *+a-g  



```
public static int way2(int[] arr, int aim){
    if (arr==null||arr.length<1||aim<0){
        return 0;
    }

    Info info = getInfo(arr);
    int[] coins = info.coins;
    int[] counts = info.counts;
    int N = coins.length;
    int[][] dp = new int[N+1][aim+1];
    dp[N][0]=1;
    for (int i = N-1; i >=0 ; i--) {
        for (int rest = 0; rest <=aim ; rest++) {
           //a 处的值
            dp[i][rest] = dp[i+1][rest];
            //* 处的值
            if(rest-coins[i]>=0){
                dp[i][rest]+=dp[i][rest-coins[i]];
            }
            //g 处的值
            int d = rest-((counts[i]+1)*coins[i]);
            if(d>=0){
                dp[i][rest]-=dp[i+1][d];
            }
        }
    }
    return dp[0][aim];
}
```





#### 题目5

```
给定5个参数，N，M，row，col，k
表示在N*M的区域上，醉汉Bob初始在(row,col)位置
Bob一共要迈出k步，且每步都会等概率向上下左右四个方向走一个单位
任何时候Bob只要离开N*M的区域，就直接死亡
返回k步之后，Bob还在N*M的区域的概率
```

思考:  1. 难点----如何表达离开 N*M 的区域

2. 范围尝试模型+ 概率计算    概率 = 符合情况的总数/所有情况的总数

1.暴力尝试:

```
public static double way(int row, int col, int N, int M, int k) {

    return process(row, col, N, M, k) / Math.pow(4, k);
}

public static int process(int row, int col, int N, int M, int rest) {

    //离开棋盘
    if (row < 0 || row == N || col < 0 || col == M) {
        return 0;
    }
    if (rest == 0) {
        return 1;
    }
    int up = process(row - 1, col, N, M, rest - 1);
    int down = process(row + 1, col, N, M, rest - 1);
    int left = process(row, col - 1, N, M, rest - 1);
    int right = process(row, col + 1, N, M, rest - 1);
    return up + down + left + right;

}
```



2.动态规划:    此题的依赖范围有些不确定,所以不需进行优化 &&  与20.题目二类似当有base case 条件为多个组合时 尝试封装函数

```
public static double way2(int N, int M, int k,int row,int col) {
    int[][][] dp = new int[N+1][M+1][k + 1];

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            dp[i][j][0] = 1;
        }
    }
    for (int rest = 1; rest <= k; rest++) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                dp[i][j][rest] = pick(dp,N,M,i-1,j,rest-1)
                +pick(dp,N,M,i+1,j,rest-1)+ pick(dp,N,M,i,j-1,rest-1)
                        +pick(dp,N,M,i,j+1,rest-1);

            }
        }
    }

   return dp[row][col][k]/Math.pow(4,k);
}

//条件封装
public static int pick(int[][][] dp,int N, int M, int row, int col,int rest){
    //复合条件
    if(row<0||row==N||col<0||col==M){
        return 0;
    }
    return dp[row][col][rest];
}
```



### (五)

重点: 斜率优化

#### 题目1

```
给定3个参数，N，M，K
怪兽有N滴血，等着英雄来砍自己
英雄每一次打击，都会让怪兽流失[0~M]的血量
到底流失多少？每一次在[0~M]上等概率的获得一个值
求K次打击之后，英雄把怪兽砍死的概率
```

思考: 1. 样本对应模型 + 概率计算

2.在k次前,怪兽的总血量已经为零,或者k次后,怪兽的血量为负数都是有效的一种方案

暴力递归:

```
public static double way1(int N, int M, int k){
    if(N<0||M<0||k<0){
        return 0;
    }

    return process(N,M,k)/Math.pow(M+1,k);
}
public static double process(int cur, int M, int rest){
    if(rest==0){
        return cur<=0?1:0;
    }

    if(cur<=0){
        return Math.pow(rest,M+1);
    }

    int ways =0;
    for (int i = 0; i <= M; i++) {
        ways+=process(cur-i,M,rest-1);
    }
    return ways;
}
```

动态规划:

```
public static double dp(int N, int M, int k){
    if(N<0||M<0||k<0){
        return 0;
    }
    long[][] dp = new long[k+1][N+1];
     dp[0][0] =1;

    for (int rest = 1; rest <=k ; rest++) {
        dp[rest][0] =(long) Math.pow(M+1,rest);
        for (int cur = 1; cur <=N; cur++) {
            int ways = 0;
            for (int i = 0; i <=M; i++) {
                ways+=cur-i<0?Math.pow(M+1,rest):dp[rest-1][cur-i];
            }
            dp[rest][cur] = ways;
        }
    }

    return dp[N][k]/Math.pow(M+1, k);
}
```

优化后的动态规划: 同样因为dp值有枚举行为产生, 所以需要优化

与 21.题目4类似

```
public static double dp1(int N, int M, int k){
        if(N<0||M<0||k<0){
            return 0;
        }
        long[][] dp = new long[k+1][N+1];
        dp[0][0] =1;

        for (int rest = 1; rest <=k ; rest++) {
            dp[rest][0] =(long) Math.pow(M+1,rest);
            for (int cur = 1; cur <=N; cur++) {
                dp[rest][cur] = dp[rest-1][cur]+dp[rest-1][cur-1];
                if((cur-M-1)>=0){
                    dp[rest][cur]-=dp[rest-1][cur-M-1];
                }else{
                    dp[rest][cur]-=Math.pow(M+1,rest-1);
                }

            }
        }

     return dp[k][N]/Math.pow(M+1, k);
}
```



#### 题目2

```
arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。
每个值都认为是一种面值，且认为张数是无限的。
返回组成aim的最少货币数
```

从左往右模型

暴力递归:

```
public static int way1(int[] arr, int aim){

    return process(arr,0,aim);
}


public static int process(int[] arr, int index, int rest){


    if(index==arr.length){
        return rest==0?0:Integer.MAX_VALUE;
    }

    int way = Integer.MAX_VALUE;
    for (int i = 0; i * arr[index] <= rest; i++) {
        int next = process(arr,index+1, rest-(i*arr[i]));
        if(next!=Integer.MAX_VALUE){
            way = Math.min(way,next+i);
        }

    }

    return way;
}
```



动态规划:

分析位置依赖 :

![image](https://user-images.githubusercontent.com/71537130/154783157-b6cc0f9d-d3a8-4b16-bf2d-a7161629f83e.png)




观察可知  :

? =  Math.min(a,b,c,d,e,...........)  *= Math.min(b,c,d,e,.........)  * 是代表用了一张的情况 , 位置已经是除了a 以外的最小值, 

所以 ? = Math.min(*+1,a);



```
public static int dp(int[] arr, int aim){
	if(aim==0){
		return 0;
	}
    int N = arr.length;
    int[][] dp = new int[N+1][aim+1];

    for (int i = 1; i <=aim; i++) {
        dp[N][i] = Integer.MAX_VALUE;
    }

    for (int i = N-1; i >=0; i--) {
        for (int rest = 0; rest <=aim; rest++) {
            dp[i][rest] = dp[i+1][rest];
            if(rest-arr[i]>=0&&dp[i][rest-arr[i]]!=Integer.MAX_VALUE){
                dp[i][rest] =Math.min(dp[i][rest],dp[i][rest-arr[i]]+1);
            }

        }
    }
    return dp[0][aim];
}
```





#### 题目3

```
给定一个正数n，求n的裂开方法数，
规定：后面的数不能比前面的数小
比如4的裂开方法有：
1+1+1+1、1+1+2、1+3、2+2、4
5种，所以返回5
```

思考: 

1.按照题目, 每个数需要最开始从1拆分,每次拆分包括之前拆出来的数---pre, 和剩余待拆出的部分----rest

2.当前尝试拆分的可能是  pre<=cur<=rest



```
public static int way(int n){
    if(n<=0){
        return 0;
    }
    if(n==1){
        return 1;
    }
    //最开始从1拆分
    return process(1,n);
}
//上一个拆出来的是pre,当前还剩rest
//尝试拆的可能是从pre ~ rest
public static int process(int pre,int rest){
    if(rest==0){
        return 1;
    }
    if(pre>rest){
        return 0;
    }
    int ways =0;
    
    //当前尝试拆分的可能是  pre<=cur<=rest
    for (int i = pre; i <=rest; i++) {
        ways+=process(i,rest-i); }
    return ways;
}
```



动态规划:

```
public static int dp(int n){
    if(n<=0){
        return 0;
    }
    if(n==1){
        return 1;
    }

    int[][] dp = new int[n+1][n+1];
    for (int pre = 1; pre <=n ; pre++) {
        dp[pre][0] = 1;
        dp[pre][pre]= 1;
    }

    for (int pre = n-1; pre>=1 ; pre--) {
        for (int rest = pre+1; rest <=n; rest++) {
            int ways = 0;
            for (int first = pre; first <=rest ; first++) {
                ways+=rest-first>=0?dp[first][rest-first]:0;
            }
            dp[pre][rest] = ways;
        }
    }

    return dp[1][n];

}
```





### (六)

#### 题目一

```
给定一个正数数组arr，
请把arr中所有的数分成两个集合，尽量让两个集合的累加和接近
返回最接近的情况下，较小集合的累加和
```

思考: 从左往右模型

难点---问题转化    尽量让两个集合的累加和接近的情况下,较小集合累加和 ------转化成  arr 累加和  sum /2 后  求 <= sum/2 的最大值

暴力递归:

```
public static int way(int[] arr) {
    if (arr == null || arr.length < 2) {
        return 0;
    }
    int sum = 0;
    for (int i = 0; i < arr.length; i++) {
        sum += arr[i];
    }
    return process(arr, sum / 2, 0);

}


public static int process(int[] arr, int rest, int index) {
    if (index == arr.length) {
        return 0;
    }
    int p1 = process(arr, rest, index + 1);
    int p2 = arr[index] <= rest ? process(arr, rest - arr[index], index + 1) +   arr[index] : 0;
    return Math.max(p1, p2);

}
```



#### 题目二

```
给定一个正数数组arr，请把arr中所有的数分成两个集合
如果arr长度为偶数，两个集合包含数的个数要一样多
如果arr长度为奇数，两个集合包含数的个数必须只差一个
请尽量让两个集合的累加和接近
返回最接近的情况下，较小集合的累加和
```

思路: 1.沿用上题的思路,只是在增加一个表示个数的变量 count  

2.奇数个数时, 需要讨论

暴力递归:

```
public  static int right(int[] arr){
    if(arr==null||arr.length<2){
        return 0;
    }
    int N = arr.length;
    int sum = 0;
    for(int value: arr){
        sum+=value;
    }
    int aim = sum/2;
    int count = N/2;
    if((N&1)==0){ //偶数个数
        return process(arr,0,count,aim);
    }else {//奇数个数
        return Math.max(process(arr,0,count,aim),process(arr,0,count+1,aim));
    }

}


public static int process(int[] arr, int index, int count, int rest){
    if(index==arr.length){
        return count==0?0:-1;
    }

    int p1 = process(arr,index+1,count,rest);
    int p2 =-1;
    int next = -1;

    if(arr[index]<=rest){
       next = process(arr,index+1,count-1,rest-arr[index]);
    }
    if(next!=-1){
        p2 = arr[index]+next;
    }
    return Math.max(p1,p2);
}
```



动态规划:

```
public static int dp(int[] arr){
    if(arr==null||arr.length<2){
        return 0;
    }
    int N = arr.length;
    int sum=0;
    for(int v:arr){
        sum+=v;
    }
    int aim = sum/2;
    int count = (N+1)/2;
    int[][][] dp = new int[N+1][count+1][aim+1];
    for (int c = 1; c<=count ; c++) {
        for (int r = 0; r <=aim ; r++) {
            dp[N][c][r] = -1;
        }
    }
    for (int i = N-1; i >=0; i++) {
        for (int c = 0; c <=count ; c++) {
            for (int r = 0; r <= aim; r++) {
                int p1 = dp[i+1][c][r];
                int next =-1;
                int p2 =-1;
                if(arr[i]<=r){
                    next = dp[i+1][c-1][r-arr[i]];
                }
                if(next!=-1){
                    p2 = arr[i]+next;
                }
                dp[i][c][r] = Math.max(p1,p2);
            }
        }
    }

    return (N&1)==0?dp[0][count-1][aim]:Math.max(dp[0][count][aim],dp[0][count-1][aim]);
}
```



#### 题目三*

```
N皇后问题是指在N*N的棋盘上要摆N个皇后，
要求任何两个皇后不同行、不同列， 也不在同一条斜线上
给定一个整数n，返回n皇后的摆法有多少种。n=1，返回1
n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0
n=8，返回92
```



### 26.动态规划---斐波那契模型

#### 1.模型讲解

![image](https://user-images.githubusercontent.com/71537130/154783419-668f41bf-265d-4c7f-8ec2-5acddb066a51.png)






#### 2.x的N次方的O(logN)解法

原理: 利用 N 次方 的N 对应二进制向右位移, x 不断自乘

![image](https://user-images.githubusercontent.com/71537130/154783447-d0f7fba5-b20b-4895-b874-c90056b4d753.png)




```
  public static int power(int x, int p){
        int result = 1;
        //两种循环方式均可
        //方式一
        while (p!=0){
            if((p&1)!=0){
               result*=x;
            }
            x*=x;
           p=p>>1;
       }

       //方式二
        for (;p!=0;p>>=1){
            if((p&1)!=0){
                result*=x;
            }
            x*=x;
        }
        
        return result;
    }
```



### 四边形不等式




## 专题二: 数据结构

### 6.堆 & 7. 加强堆

```
堆结构: 连续区间上   arr[i]  > arr[2*i+1]  && arr[i] > arr[2*i+2]
i位置的父亲: (i-1)/2  左孩子: i*2+1 右孩子: i*2+2
维持堆结构的核心函数:
heapInsert(i): 从i位置向上循环不断与其父位置的数 根据规则比较,如果不符, 则交换
heapify(i):从i位置向下循环不断与其左右孩子位置的数,根据规则比较, 如果不符 则交换

加强堆的构成:
1.T[] or ArrayList<T> 构成的 heap;(必须有)
2.HashMap<T, Integer> indexMap 反向索引表;(必须有)
3.Comparator<T> comp 比较器;(不是必须看情况, 一般情况下是要有的) 
4.int heapSize; (不是必须有)

```



### 二叉树(11~13)

#### 基本算法

#### Morris 遍历

降低经典二叉树遍历额外空间复杂度O(logN)为O(1)

时间复杂度: O(N)   空间复杂度 : O(1)

遍历细节:

假设来到当前节点,开始时cur来到头节点位置

1) 如果cur没有左孩子, cur向右移动(cur = cur.right)

2)如果cur有左孩子,找到左子树上最右的节点mostRight------前驱节点:

​	a. 如果mostRight的右指针指向空,让其指向cur,

​		然后cur向左移动(cur = cur.left)

​	b. 如果mostRight的右指针指向cur,让其指向null,

​		然后cur 向右移动(cur = cur.right)

3) cur 为空时遍历停止













### 15.并查集

*注意: 能一次性初始化, 就一次性初始化, 尽量不要一个一个初始化

结构组成:

1.hashMap 版:

```
public static class Node<V> {
    V value;

    public Node(V v) {
        value = v;
    }
}

public static class Union<V> {
    HashMap<V, Node<V>> nodeMap;
    HashMap<Node<V>, Node<V>> parentMap;
    HashMap<Node<V>, Integer> sizeMap;

    public Union(List<V> values) {
        nodeMap = new HashMap<>();
        parentMap = new HashMap<>();
        sizeMap = new HashMap<>();
        for (V v : values) {
            Node node = new Node(v);
            nodeMap.put(v, node);
            parentMap.put(node, node);
            sizeMap.put(node, 1);
        }

    }

    public Boolean isSameSet(V v1, V v2) {
        return findFather(nodeMap.get(v1)) == findFather(nodeMap.get(v2));
    }

    public Node<V> findFather(Node<V> cur) {
        Stack<Node<V>> stack = new Stack<>();
        while (cur != parentMap.get(cur)) {
            stack.push(cur);
            cur = parentMap.get(cur);
        }

        while (!stack.isEmpty()) {
            parentMap.put(stack.pop(), cur);
        }

        return cur;
    }



    public void union(V a, V b){
        if(isSameSet(a,b)){
            return;
        }
        Node<V> aHead = findFather(nodeMap.get(a));
        Node<V> bHead = findFather(nodeMap.get(b));
        Integer aSize = sizeMap.get(aHead);
        Integer bSize = sizeMap.get(bHead);
        Node<V> big = aSize>=bSize?aHead:bHead;
        Node<V> small = big==aHead?bHead:aHead;
        parentMap.put(small,big);
        sizeMap.put(big, aSize+bSize);
        sizeMap.remove(small);
    }

}
```



2.数组版:

```
public static class Union{
    //parent[i] = k , i 的父亲是k;
    public int[] parent;
    //size[i] = k, i是代表点, 才有意义
    public  int[] size;
    //辅助结构-----stack 用于find() 
    public  int[] help;
    //集合数量
    public int sets;
    
    public Union(int N){
        parent = new int[N];
        size = new int[N];
        help = new int[N];
        sets = N;
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    public int find(int cur){
        int hi = 0;
        while (cur!=parent[cur]){
            help[hi] = cur;
            cur = parent[cur];
        }
        for (int i = hi; i >=0; i--) {
            parent[help[i]] = cur;
        }
        
        return cur;
    }

    public void union(int a, int b){
        int aHead = find(a);
        int bHead = find(b);
        if(aHead!=bHead){
            int big = size[a]>+size[b]?aHead:bHead;
            int small = big==aHead?bHead:aHead;
            parent[small] = big;
            size[big] = size[a]+size[b];
         sets--;   
        }
    }

}
```



#### 题目一:

https://leetcode.com/problems/friend-circles/

```
一群朋友中，有几个不相交的朋友圈
```



```
思考: i和j 认识 代表 m[i][j] 和 m[j][i] 都等于1, m[i][i]=1 (自己和自己认识),所以可以只遍历m对角线上方区域
```

  

```
public static int getResults(int[][] M){
    int N = M.length;
    //数组版Union
    Union union = new Union(N);
    for (int i = 0; i < N; i++) {
    //遍历对角线上方即可
        for (int j = i+1; j < N; j++) {
          if(M[i][j]==1){
          	union.union(i,j);
          }
            
        }
    }
    return union.sets;
}
```



#### 题目二:

https://leetcode.com/problems/number-of-islands/

```
给定一个二维数组matrix，里面的值不是1就是0，
上、下、左、右相邻的1认为是一片岛，
返回matrix中岛的数量
```

思路: 两种做法: 1.感染法-----暴力递归   2. 并查集    

1. 感染法==最优解--------将所到之处改变 0,1 以外的值

   ```
   public static int way1(char[][] grid){
       if(grid==null||grid.length<1||grid[0]==null||grid[0].length<1){
           return 0;
       }
       int num =0;
       for (int i = 0; i < grid.length; i++) {
           for (int j = 0; j < grid[0].length; j++) {
               if(grid[i][j]==1){
                   num++;
                   infect(grid,i,j);
               }
           }
       }
       return num;
   }
   
   //目的 力所能及之处改变其值
   public static void infect(char[][] grid, int i, int j){
       if(i<0||i==grid.length||j<0||j==grid[0].length){
           return;
       }
       if(grid[i][j]!='1'){
           return;
       }
       grid[i][j] =2;
       infect(grid,i+1,j);
       infect(grid,i-1,j);
       infect(grid,i,j+1);
       infect(grid,i,j-1);
   }
   ```

   

   

2. 并查集------- 将每个位置的左方和上方与当前位置合并,因为每个位置也相当与另外一个位置的右侧或下侧, 所以联通时只考虑和左侧,上侧位置的合并即可

```
public static int way2(char[][] grid){
    if(grid==null||grid.length<1||grid[0]==null||grid[0].length<1){
        return 0;
    }


    Union union = new Union(grid);

    //第一行 只有左边的值 没有上边的值
    for (int i = 1; i < grid[0].length; i++) {
        if(grid[0][i-1]=='1'&&grid[0][i]=='1'){
           union.union(0,i-1,0,i);
        }

    }
    //第一列只有上边的值没有左边的值
    for (int i = 1; i < grid.length ; i++) {
        if(grid[i-1][0]=='1'&&grid[i][0]=='1'){
            union.union(i-1,0,i,0);
        }
    }
    //其他位置 左侧和上侧都有
    for (int i = 1; i < grid.length; i++) {
        for (int j = 1; j < grid[0].length; j++) {
            if(grid[i][j] == '1'){
                if (grid[i-1][j]=='1'){
                    union.union(i-1,j,i,j);
                }
                if(grid[i][j-1]=='1'){
                    union.union(i,j-1, i,j);
                }
            }

        }
    }
    return union.getSize();
}


public static class Union{
    int[] heads;
    int[] help;
    int[] size;
    int sets;
    int counts;

    public Union(char[][] grid){
        int m = grid.length;
        int n = grid[0].length;
        int l = n*m;
        heads = new int[l];
        help = new int[l];
        size = new int[l];
        sets =0;
        counts = n;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if(grid[i][j]=='1'){
                   int index = index(i,j);
                   heads[index] =index;
                   size[index] = 1;
                   sets++;
                }
            }
        }

    }

    public int index(int i, int j){
        return i*counts+j;
    }



    public int findHead(int a){
        int hi =0;
        while (a!=heads[a]){
            help[hi++] = a;
            a = heads[a];
        }

        for (int i = 0; i <=hi; i++) {
            heads[help[i]] = a;
        }
        return a;
    }

    public void union(int aRow,int aCol, int bRow, int bCol){
        int a = index(aRow,aCol);
        int b = index(bRow,bCol);
        int aHead = findHead(a);
        int bHead = findHead(b);
        if(aHead!=bHead) {
            if (size[aHead] >= size[bHead]) {
                heads[bHead] = aHead;
                size[aHead] += size[bHead];
            } else {
                heads[aHead] = bHead;
                size[bHead] += size[aHead];
            }
            sets--;
        }
    }


    public int getSize(){
        return sets;
    }


}
```



#### 题目三:

```
题目二的升级---- 给出 m, n 代表二维矩阵的规模, 同时给出所有二维矩阵值为'1'的位置 positions, 返回list-----positions每个位置对应的岛的数量    
```

思考: 与题目二不同的是 此题是求每个 positions 位置对应的岛数量,  即将为"1" 的位置动态给出,并动态生成当前岛的数量,

```
public static List<Integer> way(int m, int n, int[][] positions){
    List<Integer> list = new ArrayList<>();
    Union union = new Union(m,n);
    for (int[] pos: positions){
        list.add(union.connect(pos[0],pos[1]));
    }
    return list;
}

public static class Union{
    int[] parent;
    int[] help;
    int[] size;
    int sets;
    int col;
    int row;

    public Union(int r,int c){
        parent = new int[r*c];
        help = new int[r*c];
        size = new int[r*c];
        sets =0;
        col = c;
        row = r;
    }


    private int getIndex(int i, int j){
        return i*col+j;
    }

    private int find(int index){
        int hi = 0;
        int p = index;
        while (p!=parent[p]){
            help[hi++] = p;
            p = parent[p];
        }

        for (int i = 0; i < hi; i++) {
            parent[help[i]] = p;
        }

        return p;
    }


    private void union(int r1, int c1, int r2, int c2){
        if(r1<0||r1==row||c1<1||c1==col||r2<0||r2==row||c2<0||c2==col){
            return;
        }
        int a= getIndex(r1,c1);
        int b = getIndex(r2,c2);

        if(size[a]==0||size[b]==0){
            return;
        }
        int f1 = find(a);
        int f2 = find(b);

        if(f1!=f2){
            if(size[f1]>=size[f2]){
                parent[f2] = f1;
                size[f1] +=size[f2];
            }else {
                parent[f1] = f2;
                size[f2] += size[f1];
            }
            sets--;
        }

    }

    public int connect(int r, int c){
        int index = getIndex(r,c);
        if(size[index]==0){
            parent[index] = index;
            size[index] = index;
            sets++;
            union(r-1,c,r,c);
            union(r+1,c,r,c);
            union(r,c-1,r,c);
            union(r,c+1,r,c);
        }
        return sets;
    }
```



#### 题目四:

```
岛问题（题目二的扩展）
如果题目二的matrix极大，设计一种可行的并行计算方案
```



思路:  先拆后和 

1.拆:   每个线程在matrix 相应的范围内计算岛的数量,后返回范围内边界处的每个'1'位置的集合代表信息----属于哪个集合----的list

2.和:   每拆分的两个范围合并的过程中,将边界处1位置进行合并







### 16.图

#### 图的表达方式

![image](https://user-images.githubusercontent.com/71537130/154783506-ea77396e-1da6-417f-9526-7f0d477f91b0.png)






1.邻接表法:

| key-->(node) | value--->(list) |
| ------------ | --------------- |
| a            | b               |
| c            | a, e, f         |
| e            |                 |
| f            | e               |

2.邻接矩阵法:

|       | a    | b    | c    | e    | f    |
| ----- | ---- | ---- | ---- | ---- | ---- |
| **a** | 0    | 3    |      |      |      |
| **b** |      | 0    | 1    |      |      |
| **c** | 7    |      | 0    | 2    | 5    |
| **e** |      |      |      | 0    |      |
| **f** |      |      |      | 6    | 0    |

3.二维矩阵法:

```
m[i] = 节点信息数组node[]  

m[i][0] = node[0] 代表边长 

```



#### 图的常见描述

点结构描述:

```

```



#### BFS遍历----图的宽度优先遍历

队列 + set, 机制: 弹出时打印

```
public static void bfs(Node start){
    Queue<Node> queue = new LinkedList<>();
    HashSet<Node> set = new HashSet<>();
    queue.add(start);
    set.add(start);
    while (!queue.isEmpty()){
        Node cur = queue.poll();
        //弹出时打印
        System.out.print(cur.value+" ");
        for (Node next : cur.nexts) {
            if(!set.contains(next)){
                queue.add(next);
                set.add(next);
            }
        }
    }
    System.out.println();
}
```



#### DFS 遍历----图的深度优先遍历

递归方式

```
public static void DFS1(Node start){
    HashSet<Node> set = new HashSet<>();
    process(start, set);
    System.out.println();
}

public static void process(Node cur , HashSet<Node> set){
    if(set.contains(cur)||cur==null){
        return;
    }
    System.out.print(cur.value+" ");
    set.add(cur);
    for(Node next: cur.nexts){
        process(next,set);
    }
}
```



迭代方式: 栈,  机制: 入栈时打印, 并且子节点入栈前要将上级节点入栈

```
public static void DFS2(Node start){
    Stack<Node> stack = new Stack<>();
    HashSet<Node> set = new HashSet<>();
    //入栈打印
    System.out.print(start.value+" ");
    stack.push(start);
    set.add(start);
    while (!stack.isEmpty()){
        Node cur = stack.pop();
        for (Node next : cur.nexts) {
            if(!set.contains(next)){
            	//将上级节点入栈
                stack.push(cur);
                //子节点入栈
                stack.push(next);
                set.add(next);
                //入栈打印
                System.out.print(next.value+" ");
                break;
            }
        }
    }
    System.out.println();
}
```

#### 图的拓扑排序

1.最简单解法 : 根据入度  反复查找入度为0,    然后销毁入度为零的影响   本质:用的是bfs 遍历

```
public static ArrayList<Node> sort1(Graph graph){
    //入度为零的点才能进入的队列
    Queue<Node> zeroQueue = new LinkedList<>();
    //结果顺序集合
    ArrayList<Node> result = new ArrayList<>();
    //标记每个点的入度
    HashMap<Node, Integer> inMap = new HashMap<>();
    
    for(Node node: graph.nodes.values()){
        //初始化每个点的入度
        inMap.put(node,node.in);
        //如果发现入度为0,进入队列
        if(node.in==0){
            zeroQueue.add(node);
        }
    }

    //遍历零度队列
    while (!zeroQueue.isEmpty()){
        Node cur = zeroQueue.poll();
        //队列弹出时,进入结果集
        result.add(cur);
        for(Node next: cur.nexts){
            //减少当前入度为零的点对后续点的入度产生的影响
            inMap.put(next,inMap.get(next)-1);
            //减少影响后,如果入度为零, 进入队列
            if (inMap.get(next)==0){
                zeroQueue.add(next);
            }
        }
    }
    return result;
}
```





2.如果x点的后序点的次数 >= y 点的后序点次 则x的拓扑序在y 的前面  ,dfs 深度遍历

https://www.lintcode.com/problem/topological-sorting

```
public static class DirectedGraphNode {
    int label;
    List<DirectedGraphNode> neighbors;
    DirectedGraphNode(int x) {
        label = x;
       neighbors = new ArrayList<DirectedGraphNode>();
    }
 }
  public static class Record{
    DirectedGraphNode label;
    long nodes;
    public Record(DirectedGraphNode l, long n){
        label = l;
        nodes = n;
    }

  }

  public static class MyComparator implements Comparator<Record> {
      @Override
      public int compare(Record o1, Record o2) {
          return o2.nodes==o1.nodes?0:(o1.nodes>o2.nodes?-1:1);
      }
  }

 public static Record process(DirectedGraphNode cur, HashMap<DirectedGraphNode,Record> map){
    if(map.containsKey(cur)){
        return map.get(cur);
    }

    long n = 0;

    for(DirectedGraphNode next: cur.neighbors){
        n+=process(next,map).nodes;

    }
    Record ans = new Record(cur,n+1);
    map.put(cur,ans);
    return ans;

 }

  public static ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
      ArrayList<DirectedGraphNode> ans = new ArrayList<>();

      HashMap<DirectedGraphNode, Record> map = new HashMap<>();
      for(DirectedGraphNode node: graph){
          process(node,map);
      }

      ArrayList<Record> list = new ArrayList<>();
      for(Record record: map.values()){
          list.add(record);
      }

      list.sort(new MyComparator());

      for(Record record: list){
          ans.add(record.label);
      }

      return ans;
  }
```



3.如果x 的深度 >= y 的深度  , x 在 y 的前面    用到:dfs

https://www.lintcode.com/problem/topological-sorting

```
public static class DirectedGraphNode {
    int label;
    List<DirectedGraphNode> neighbors;

    DirectedGraphNode(int x) {
        label = x;
        neighbors = new ArrayList<DirectedGraphNode>();
    }
}

public static class Record{
    DirectedGraphNode node;
    Integer deep;
    public  Record (DirectedGraphNode n,Integer d){
        node = n;
        deep = d;
    }
}

public static class MyComparator implements Comparator<Record> {

    @Override
    public int compare(Record o1, Record o2) {
        return o2.deep-o1.deep;
    }
}



//dfs
public static Record process(DirectedGraphNode cur, HashMap<DirectedGraphNode,Record> map){
    if(map.containsKey(cur)){
        return map.get(cur);
    }


    Integer deep = 0;

    for (DirectedGraphNode next : cur.neighbors){
        deep = Math.max(deep,process(next,map).deep);
    }
    Record record = new Record(cur,deep+1);
    map.put(cur,record);
    return record;
}


public static ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
    ArrayList<DirectedGraphNode> res = new ArrayList<>();

    HashMap<DirectedGraphNode, Record> map = new HashMap<>();


    for (DirectedGraphNode node: graph){
        process(node,map);
    }

    ArrayList<Record>  list = new ArrayList<>();

    for(Record record : map.values()){
        list.add(record);
    }

    list.sort(new MyComparator());

    for(Record record : list){
        res.add(record.node);
    }
    return res;
}
```





#### 图的最小生成树

##### 1.什么是图的最小生成树

 使得图的各个节点可以连通的最短距离

![image](https://user-images.githubusercontent.com/71537130/154783557-073bb88e-c54e-4023-9d10-196a03ae115f.png)






最小生成树为:

![image](https://user-images.githubusercontent.com/71537130/154783568-dffb27cb-8702-4d61-984b-eb801f2f4c6c.png)




##### 2.Krusal  K算法

流程: 

1.将图的边集用小根堆排序

2.从堆顶弹出的边,检查 from 点, 和 to 点 后如果没有出现在一个集合里, 用 并查集 连通,  将弹出的边加入结果集中 ; 

3.如果弹出的边的from 和 to  已经在一个集合里, 说明在图中出现了环状, 



```
public  static class Union{
  HashMap<Node, Node> parent;
  HashMap<Node, Integer> sizeMap;
  
  public Union(){
      parent = new HashMap<>();
      sizeMap = new HashMap<>();
  }
  
  public void build(Collection<Node> nodes){
      //清空之前的uion
      parent.clear();
      sizeMap.clear();
      for(Node node: nodes){
          parent.put(node,node);
          sizeMap.put(node,1);
      }
  }
  
  public boolean isSameSet(Node n1, Node n2){
      return find(n1)==find(n2);
  }
  
  public Node find(Node node){
      Stack<Node> stack = new Stack<>();
      while (node!=parent.get(node)){
          stack.push(node);
          node = parent.get(node);
      }
      
      while (!stack.isEmpty()){
          parent.put(stack.pop(),node);
      }
      
      return node;
  }
  
  public void union(Node n1, Node n2){
      if(isSameSet(n1,n2)){
          return;
      }
      Node head1 = find(n1);
      Node head2 = find(n2);
      Integer size1 = sizeMap.get(head1);
      Integer size2 = sizeMap.get(head2);
      Node big = size1>=size2?head1:head2;
      Node small = big==head1?head2:head1;
      parent.put(small,big);
      sizeMap.put(big,size1+size2);
      sizeMap.remove(small);
  }
}


public  static class MyComparator implements Comparator<Edge>{

    @Override
    public int compare(Edge o1, Edge o2) {
        return o1.weight-o2.weight;
    }
}

public static Set<Edge> K(Graph graph){
    HashSet<Edge> result = new HashSet<>();
    Union union = new Union();
    union.build(graph.nodes.values());
    PriorityQueue<Edge> queue = new PriorityQueue<>(new MyComparator());
    for(Edge edge: graph.edges){
        queue.add(edge);
    }
    
    while (!queue.isEmpty()){
        Edge cur = queue.poll();
        
        if(union.isSameSet(cur.from,cur.to)){
            result.add(cur);
            union.union(cur.from,cur.to);
        }
    }
    return result;
}
```



##### 3.Prim算法

```
public static class MyComparator implements Comparator<Edge> {

    @Override
    public int compare(Edge o1, Edge o2) {
        return o1.weight - o2.weight;
    }
}

public static ArrayList<Edge> prim(Graph graph){
    ArrayList<Edge> result = new ArrayList<>();
    //解锁的点集
    HashSet<Node> nodeSets = new HashSet<>();
    //可以到达的边
    PriorityQueue<Edge> edgeble = new PriorityQueue<>(new MyComparator());

    for(Node node : graph.nodes.values()){
        if(!nodeSets.contains(node)){
            nodeSets.add(node);
            for(Edge edge : node.edges){
                edgeble.add(edge);
            }

            while (!edgeble.isEmpty()){
                Edge cur = edgeble.poll();
                Node n = cur.to;
                if(!nodeSets.contains(cur.to)){
                    result.add(cur);
                    nodeSets.add(n);
                    for(Edge e: n.edges){
                        edgeble.add(e);
                    }
                }
            }
        }
    }
    return result;
}
```





#### Dijksral 算法

流程: 对

从start点出发,

方式一:

```
public static HashMap<Node,Integer> Dijkstra(Node start){
    HashMap<Node, Integer> map = new HashMap<>();
    map.put(start,0);
    HashSet<Node> set = new HashSet<>();
    Node minNode = getMinEdge(map,set);
    while (minNode!=null){
        Integer distance = map.get(minNode);
        for (Edge e: minNode.edges){
            if(map.containsKey(e.to)){
                map.put(e.to,Math.min(map.get(e.to),distance+e.weight));
            }else {
                map.put(e.to,distance+e.weight);
            }
        }
        set.add(minNode);
        minNode = getMinEdge(map,set);
    }
    return map;
}

public static Node getMinEdge(HashMap<Node, Integer> map,HashSet<Node> set){
    Node result = null;
    Integer min = Integer.MAX_VALUE;
    for(Map.Entry<Node,Integer> entry : map.entrySet() ){
        if(!set.contains(entry.getKey())&&entry.getValue()<min){
            min = entry.getValue();
            result = entry.getKey();
        }
    }
    return result;
}
```

方式二:





#### A* 算法

#####  曼哈顿距离

坐标(x1,y1)的i点与坐标(x2,y2)的j点的曼哈顿距离为：d(i,j)=|X1-X2|+|Y1-Y2|.

Dijkstra算法的升级   ,具有导向性的 , 到达目标点的最短路径

过程和Dijskra高度相处
有到终点的预估函数
只要预估值<=客观上最优距离，就是对的
预估函数是一种吸引力：
1）合适的吸引力可以提升算法的速度
2）吸引力“过强”会出现错误



### 费尔曼算法

与dijkstra 相似

但是类似宽度遍历

最多扩N-1次得到最优解, 如果第N次得到更好的解, 则说明有负向环











### 24.滑动窗口----窗口内最大值或最小值的更新结构

实现原理: 

1.所需变量: L, R 指针 + 双端队列, 尾进头出,队列中保存下标值

2.所需动作:

i. 右扩:  R++ 代表窗口在往右扩,右扩时保证双端队列中保持的arr的下标所代表的值是从大到小(或从小到大),如果遇到相等的值,则将队列的值弹出,而存入最新的index

ii. 过期:  检查L是否过期即大于窗口,大于则从头部弹出下标

iii. 收集结果信息

#### 题目一:

```
窗口内最大值或最小值更新结构的实现
假设一个固定大小为W的窗口，依次划过arr，
返回每一次滑出状况的最大值
例如，arr = [4,3,5,4,3,3,6,7], W = 3
返回：[5,5,5,4,6,7]
```



```
public static int[] slidewindow(int[] arr, int w){
     if(arr==null||w<1||arr.length<w){
         return null;
     }

     int N = arr.length;
     int[] ans = new int[N-w+1];
     LinkedList<Integer> queue = new LinkedList<>();
     int index =0;
    for (int R = 0; R < N; R++) {
        //判断需要添加进队列的数和队列末端的数是否符合从大到小的关系,如果末端<= 添加的数需要弹出
        while (!queue.isEmpty()&&arr[queue.peekLast()]<=arr[R]){
            queue.pollLast();
        }
        //从末端添加
        queue.addLast(R);
        //判断窗口头部的数是否过期
        if(queue.peekFirst()==R-w){
            queue.pollFirst();
        }
        //收集窗口的最大值
        if(R>=w-1){
            ans[index++] = arr[queue.peekFirst()];
        }

    }

    return ans;
}
```



#### 题目二:

```
给定一个整型数组arr，和一个整数num
某个arr中的子数组sub，如果想达标，必须满足：sub中最大值 – sub中最小值 <= num，
返回arr中达标子数组的数量
```

思路:

1.如果L~R范围上 的max -min <= num  达标 , 则 L~R范围上的所有子数组都会达标, 因为范围变小 max会变小,min会变大

2.如果L~R范围 不达标,则往左扩 ,或者往右扩 都不会达标

3.需要同时生成最大值窗口和最小值窗口------两个队列

4.流程 L==0开始 R往右扩 扩到不达标位置,收集答案, 然后 L=1 , R 从上次不达标位置继续往下扩到再次不达标收集答案,  L=2,........依次类推

```
public static int getCount(int[] arr, int sum) {
    if (arr == null || arr.length < 1) {
        return 0;
    }
    int N = arr.length;
    int count = 0;
    LinkedList<Integer> maxq = new LinkedList<>();
    LinkedList<Integer> minq = new LinkedList<>();
    int R = 0;
    for (int L = 0; L < N; L++) {

        while (R < N) {//整个这个大while 代表求得当前L, R扩到不达标的位置
            while (!maxq.isEmpty() && arr[maxq.peekLast()] <= arr[R]) {
                maxq.pollLast();
            }
            maxq.addLast(R);
            while (!minq.isEmpty() && arr[minq.peekLast()] >= arr[R]) {
                minq.pollLast();
            }
            minq.addLast(R);

            if (arr[maxq.peekFirst()] - arr[minq.peekFirst()] > sum) {
                break;
            } else {
                R++;
            }

        }
        //收集当前个数
        count += R - L;
        
        //弹出窗口过期的值
        if (maxq.peekFirst() == L) {
            maxq.pollFirst();
        }
        if (minq.peekFirst() == L) {
            minq.pollFirst();
        }

    }
    return count;

}
```



#### 题目三

```
加油站的良好出发点问题
gas[] 代表每个加油站有多少油,
cost[] 代表当前加油站与下一个加油站之间的距离 , n-1 代表最后一个加油站到第一个加油站的距离
返回 boolean[] -----每个加油站作为开始起点能否跑完一圈

```



思路: 1.转换问题 生成arr[i] = gas[i]-cost[i], 即求从 arr[i] 开始求sum 如果中途sum<=0 则为false

2.根据生成的arr[] 做成长度为2倍的 前缀和数组 s[], 这样可以显示每一个加油站转完一圈的经历的数值变化

3.加油站总个数为N, s[i]作为起始点,  每N+1个数为一组, 组内每个数减去起始点的前一个数--s[i-1] 后,则是s[i] 作为起始点,转完一圈所经历的油量的变化

4. 根据第三点,用滑动窗口求得每组最小值, 减去起始点前一个数 s[i-1] 后  ,如果小于零  ,则代表s[i] 作为起始点不能跑完一圈,反之为true.

```
public static boolean[] answer(int[] gas, int[] cost){
    if(gas==null||gas.length<1||cost==null||cost.length<1||gas.length!=cost.length){
        return null;
    }
    int N = gas.length;
    int[] sum = new int[N<<1];
    for (int i = 0; i < N; i++) {
        sum[i] = gas[i] - cost[i];
        sum[i + N] = gas[i] - cost[i];
    }
    for (int i = 1; i < sum.length; i++) {
        sum[i] += sum[i - 1];
    }

    boolean[] ans = new boolean[N];
    LinkedList<Integer> queue = new LinkedList<>();

    int index = 0;
    for (int R = 0; R <sum.length; R++) {
        while (!queue.isEmpty()&&sum[queue.peekLast()]>=sum[R]){
            queue.pollLast();
        }
        queue.addLast(R);
         //窗口长度为N+1,所以过期 R-N-1 为过期的下标
        if(queue.peekFirst()==R-N-1){
            queue.pollFirst();
        }
        if(R>=N){
            if(R==N){//起始点为index==0时,只需要判断最小值是否小于0
                ans[index++] = sum[queue.peekFirst()]>=0?true:false;
            }else {//其他起始点则需要减去起始点前一个数后再判断
                ans[index++] = sum[queue.peekFirst()]-sum[R-N-1]>=0?true:false;
            }

        }
    }

    return ans;
}
```





#### 题目四 *

```
动态规划中利用窗口内最大值或最小值更新结构做优化（难）
arr是货币数组，其中的值都是正数。再给定一个正数aim。
每个值都认为是一张货币，
返回组成aim的最少货币数
注意：因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了
```



### 25.单调栈

#### 实现原理:

1.无重复数版本

栈:保存数组下标  , 栈内顺序: 从底往上保持数组下标代表的数组从小至大(从大到小, 顺序根据题目自定):

比较当前数字和栈顶的代表的数:

大于:入栈

小于: 如果比栈顶小, 则需要将栈顶元素弹出并记录栈顶元素信息: 左侧比其小的最近距离的位置 = 弹出后的栈顶元素的位置 , 右侧比其小的最近距离位置= 当前的数的位置;



```
public static int[][] getNearLess(int[] arr){
    int N = arr.length;
    int[][] res = new int[N][2];
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < N; i++) {
    	//比栈顶的数小,收集res信息
        while (!stack.isEmpty()&&arr[stack.peek()]>arr[i]){
            int cur = stack.pop();
            int leftLess = stack.isEmpty()?-1:stack.peek();
            res[cur][0] = leftLess;
            res[cur][1] = i;
        }
        //栈是空的或者大于栈顶, 入栈
        stack.push(i);
    }
    
    //栈内剩余元素的统计
    while(!stack.isEmpty()){
        int cur = stack.pop();
        int leftLess = stack.isEmpty()?-1:stack.peek();
        res[cur][0] = leftLess;
         //右边没有比之小的,都是-1;
        res[cur][1] = -1;
    }

    return res;
}
```



2.有重复数版本

栈:保存数组下标List  , 栈内顺序: 从底往上保持数组下标代表的数组从小至大(从大到小, 顺序根据题目自定):

比较当前下标代表的数和栈顶的代表的数:

大于:创建list入栈

小于: 如果比栈顶小, 则需要将栈顶元素list弹出并记录list元素信息: 左侧比其小的最近距离的位置 = 弹出后的栈顶list的最后元素的位置 , 右侧比其小的最近距离位置= 当前的数的位置;

等于: 将当前数组下标,插入栈顶list



```
public static int[][] getNearLess2(int[] arr){
    int N = arr.length;
    int[][] res = new int[N][2];
    Stack<ArrayList<Integer>> stack = new Stack<>();
    for (int i = 0; i < N; i++) {
    	//弹出时统计
        while (!stack.isEmpty()&&arr[stack.peek().get(stack.peek().size()-1)]>arr[i]){
            ArrayList<Integer> cur = stack.pop();
            int leftLess = stack.isEmpty()?-1:stack.peek().get(stack.peek().size()-1);
            for(Integer j: cur){
                res[j][0] = leftLess;
                res[j][1] = i;
            }

        }
        if(!stack.isEmpty()&&arr[stack.peek().get(0)]==arr[i]){//重复数的情况
            stack.peek().add(i);
        }else {//入栈
            ArrayList<Integer> list = new ArrayList<>();
            list.add(i);
            stack.push(list);
        }

    }
	//栈内剩余数的统计
    while (!stack.isEmpty()){
        ArrayList<Integer> cur = stack.pop();
        int leftLess = stack.isEmpty()?-1:stack.peek().get(stack.peek().size()-1);
        for(Integer item: cur){
            res[item][0] =  leftLess;
            res[item][1] = -1;
        }
    }
    
    return res;
}
```

3. 数组实现stack版

   



#### 题目一:

```
给定一个只包含正数的数组arr，arr中任何一个子数组sub，
一定都可以算出(sub累加和 )* (sub中的最小值)是什么，
那么所有子数组中，这个值最大是多少？
```

思路: 考点 前缀和+单调栈

1.sub 最小值--------每个arr位置作为最小值的sub

2.根据思路1 sub最小值固定了,得到最大值代表 sub 累加和最大-------sub的个数经量多

3.根据1,2---------单调栈

4.累加和 可以用前缀和做加速

```
public static int getResult(int[] arr){
    int N = arr.length;
    
    //前缀和数组
    int[] sum = new int[N];
    sum[0] = arr[0];
    for (int i = 1; i < N; i++) {
        sum[i] = sum[i-1]+arr[i];
    }
    int ans =0;
    Stack<Integer> stack = new Stack<>();
    //单调栈结构
    for (int i = 0; i < N; i++) {
        while (!stack.isEmpty()&&arr[stack.peek()]>=arr[i]){
            int cur = stack.pop();
            int leftLess = stack.isEmpty()?-1: stack.peek();

            int s = leftLess==-1?sum[i-1]:sum[i-1]-sum[leftLess];
            //弹出时结算结果
            ans = Math.max(ans,s*arr[cur]);
        }
        stack.push(i);
    }

    while (!stack.isEmpty()){

        int cur = stack.pop();
        int leftLess = stack.isEmpty()?-1: stack.peek();
        int s = leftLess==-1?sum[N-1]:sum[N-1]-sum[leftLess];
        //弹出时,计算结果
        ans = Math.max(ans,s*arr[cur]);
    }

    return ans;
}
```



#### 题目二:

https://leetcode.com/problems/largest-rectangle-in-histogram/submissions/

```
给定一个非负数组arr，代表直方图的高，返回直方图的最大长方形面积
```



```
public static int getResult(int[] arr) {
    int N = arr.length;
    Stack<Integer> stack = new Stack<>();
   int ans = Integer.MIN_VALUE;
    for (int i = 0; i < N; i++) {
        while (!stack.isEmpty()&&arr[stack.peek()]>=arr[i]){
            int cur = stack.pop();
            int leftLess = stack.isEmpty()?-1:stack.peek();
            int count = i-1-leftLess;
            ans = Math.max(ans,count*arr[cur]);
        }
        stack.push(i);
    }

    while (!stack.isEmpty()){

        int cur = stack.pop();
        int leftLess = stack.isEmpty()?-1:stack.peek();
        int count = N-1-leftLess;
        ans = Math.max(ans,count*arr[cur]);
    }
    return ans;
}
```



#### 题目三:

https://leetcode.com/problems/maximal-rectangle/submissions/

```
给定一个二维数组matrix，其中的值不是0就是1，返回全部由1组成的最大子矩形内部有多少个1（面积）
```

思考:需要用到压缩数组技巧

```
public static int handle(char[][] matrix){
    int[] arr = new int[matrix[0].length];
    int res = Integer.MIN_VALUE;
    for (int i = 0; i < matrix.length; i++) {
        for (int j = 0; j < matrix[0].length; j++) {
        	//数组压缩处理
            arr[j] = matrix[i][j]=='0'?0:arr[j]+1;
        }
        res = Math.max(res,getMax(arr));
    }

    return res;
}

public static int getMax(int[] arr){
    int max = Integer.MIN_VALUE;
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < arr.length; i++) {
        while (!stack.isEmpty()&&arr[stack.peek()]>=arr[i]){
            int cur = stack.pop();
            int leftLess = stack.isEmpty()?-1:stack.peek();
            int count = i-1-leftLess;
            max = Math.max(max,count*arr[cur]);
        }
        stack.push(i);
    }

    while (!stack.isEmpty()){
        int cur = stack.pop();
        int leftLess = stack.isEmpty()?-1:stack.peek();
        int count = arr.length-1-leftLess;
        max = Math.max(max,count*arr[cur]);

    }


    return max;
}
```



#### 题目四:

https://leetcode.com/problems/count-submatrices-with-all-ones

```
给定一个二维数组matrix，其中的值不是0就是1，返回全部由1组成的子矩形数量
```



```
 public static int handle(int[][] mat){
     int[] arr= new int[mat[0].length];
     int num =0;
     for (int i = 0; i < mat.length; i++) {
         for (int j = 0; j < mat[0].length; j++) {
             arr[j] = mat[i][j]==0?0:arr[j]+1;
         }
         num+=getCounts(arr);
     }
     return num;
 }
 

 public static int getCounts(int[] arr){
     int N = arr.length;
     int num =0;
     Stack<Integer> stack = new Stack<>();
     for (int i = 0; i < N; i++) {
         while (!stack.isEmpty()&&arr[stack.peek()]>=arr[i]){
            int cur = stack.pop();
            int left = stack.isEmpty()?-1:stack.peek();
            int L = i-1-left;
            int down =Math.max(left==-1?0:arr[left],arr[i]);
            num += num(L)*(arr[cur]-down);
         }
         stack.push(i);

     }
      while (!stack.isEmpty()){
          int cur = stack.pop();
          int left = stack.isEmpty()?-1:stack.peek();
          int L = N-1-left;
          int down = left==-1?0:arr[left];
          num += num(L)*(arr[cur]-down);
      }

     return num;
 }


public static int num(int n){
     return ((n*(n+1))>>1);
}
```



## 专题三: 字符串的处理

### 子串, 子序列问题

#### 最长公共子串 

#### 最长公共子序列



#### 最长无重复字符子串



#### 字符串匹配 :  KMP



#### 最长回文子串 : Manature

```
概念: 回文半径, 最右回文边界






```













